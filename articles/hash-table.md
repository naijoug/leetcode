# `Hash Table` - “哈希表”

## `LRU Cache` - “最近最少使用缓存”

- [LeetCode 146](https://leetcode.cn/problems/lru-cache/)
  > `get` `put` 操作需要 O(1) 的平均时间复杂度

【思路】: 哈希表 + 双向链表
  * 首先解决数据的缓存问题。由于需要 O(1) 的时间复杂度，所以应该很自然的想到了使用哈希表来保存数据。这样保存和查询都可以做到 O(1) 的时间复杂度。
  * 再来解决最近最少使用的问题。这需要使用双向链表的结构来保存数据，链表头部为最少使用的数据，链表尾部为最近使用的数据。
    + 查询数据时，这个查询过的数据为最近使用，也就是需要移除就之前链表中的这个数据，将这个数据重新加入到链表尾部。
    + 添加数据时，如果这个 key 已存在，则移除旧数据，将新数据加入链表尾部；如果 key 不存在，需要判断缓存是否已满，如果已满则移除链表头部最少使用数据，添加新数据到链表尾部，如果未满则直接添加新数据到链表尾部。

## `LFU Cache` - “最不经常使用缓存”

- [LeetCode 460](https://leetcode.cn/problems/lfu-cache)
  > `get` `put` 操作需要 O(1) 的时间复杂度

【思路】: 双哈希表
  * 数据缓存的问题。同 `LRU` 一样需要哈希表来保证数据存取的 O(1) 的时间复杂度。
  * 最不经常时间的问题。这个需要为没有数据加上一个 frequency 使用频率计数值来进行标记。关键点在于需要 O(1) 时间复杂度，那么使用
